# -*- coding: utf-8 -*-
"""
Spyder Editor

This is a temporary script file.
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
from scipy.optimize import minimize_scalar
from scipy import stats


def maximize(g, a, b, args):
    """
    Maximize the function g over the interval [a, b].

    We use the fact that the maximizer of g on any interval is
    also the minimizer of -g.  The tuple args collects any extra
    arguments to g.

    Returns the maximal value and the maximizer.
    """

    objective = lambda x: -g(x, *args)
    result = minimize_scalar(objective, bounds=(a, b), method='bounded')
    maximizer, maximum = result.x, -result.fun
    return maximizer, maximum

class OptimalGrowthModel:

    def __init__(self,
                 r,            # reward function
                 f,            # renewal function
                 β=0.90,       # discount factor
                 μ=0,          # shock location parameter
                 s=0.25,        # shock scale parameter
                 grid_max=4,
                 grid_size=120,
                 shock_size=250,
                 seed=1234):

        self.r, self.f, self.β, self.μ, self.s = r, f, β, μ, s

        # Set up grid
        self.grid = np.linspace(1e-5, grid_max, grid_size)

        # Store shocks (with a seed, so results are reproducible)
        np.random.seed(seed)
        self.shocks = np.exp(μ + s * np.random.randn(shock_size))

    def objective(self, a, s, v_array):
        """
        Right hand side of the Bellman equation.
        """

        r, f, β, shocks = self.r, self.f, self.β, self.shocks

        v = interp1d(self.grid, v_array,fill_value="extrapolate")

        return r(a) + β * np.mean(v(f(s - a) * shocks))
    
def T(og, v):
    """
    The Bellman operator.  Updates the guess of the value function
    and also computes a v-greedy policy.

      * og is an instance of OptimalGrowthModel
      * v is an array representing a guess of the value function

    """
    v_new = np.empty_like(v)
    v_greedy = np.empty_like(v)

    for i in range(len(grid)):
        s = grid[i]
        
        # Maximize RHS of Bellman equation at state s
        a_star, v_max = maximize(og.objective, 1e-10, min(s,5), (s, v))
        v_new[i] = v_max
        v_greedy[i] = a_star

    return v_greedy, v_new

α = 0.25
def fcd(k):
    return k**α

def rwd(m):
    return m*(5-m)

og = OptimalGrowthModel(r=rwd, f=fcd)
grid = og.grid

v = rwd(grid) # An initial condition
n = 20

fig, ax = plt.subplots()

ax.plot(grid, v, color=plt.cm.jet(0),
        lw=2, alpha=0.6, label='Initial condition')

for i in range(n):
    v_greedy, v = T(og, v)  # Apply the Bellman operator

    ax.plot(grid, v, color=plt.cm.jet(i / n), lw=2, alpha=0.6)




ax.legend()
ax.set(ylim=(0, 30), xlim=(0, 4.2))
plt.show()

opt_pi = interp1d(grid, v_greedy)

s = []
np.random.seed(1234)
noise = np.exp(0 + 0.50 * np.random.randn(10))
s.append(1)
for i in range(10):
    res = fcd(s[i] - opt_pi(s[i])) * noise[i]
    s.append(res)
y = np.array(s)
std,mean = np.std(y),np.mean(y)
print("std=",std,"mean=",mean)
plt.plot(s)
plt.xlabel("time")
plt.ylabel("state")
plt.title("Optimal path for T=10")

